/**************************************************************************
 * C S 429 system emulator
 * 
 * instr_Decode.c - Decode stage of instruction processing pipeline.
 **************************************************************************/ 

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <assert.h>
#include "err_handler.h"
#include "instr.h"
#include "instr_pipeline.h"
#include "forward.h"
#include "machine.h"
#include "hw_elts.h"

#define SP_NUM 31
#define XZR_NUM 32

extern machine_t guest;
extern mem_status_t dmem_status;

extern int64_t W_wval;

/*
 * Control signals for D, X, M, and W stages.
 * Generated by D stage logic.
 * D control signals are consumed locally. 
 * Others must be buffered in pipeline registers.
 * STUDENT TO-DO:
 * Generate the correct control signals for this instruction's
 * future stages and write them to the corresponding struct.
 */

static comb_logic_t 
generate_DXMW_control(opcode_t op,
                      d_ctl_sigs_t *D_sigs, x_ctl_sigs_t *X_sigs, m_ctl_sigs_t *M_sigs, w_ctl_sigs_t *W_sigs) {
    D_sigs->src2_sel = false;
    M_sigs->dmem_read = false;
    M_sigs->dmem_write = false;
    W_sigs->w_enable = false;
    X_sigs->valb_sel = false;
    X_sigs->set_CC = false;
    X_sigs->valb_sel = false;
    W_sigs->dst_sel = false;
    W_sigs->wval_sel = false;
    switch(op) {
        //everything other than STUR, B, B. cond, RET, NOP, HLT, CMP, TST has w_enable
        case OP_STUR:
            D_sigs->src2_sel = true;
            M_sigs->dmem_write = true;
            W_sigs->w_enable = false;
            break;
        case OP_LDUR:
            M_sigs->dmem_read = true;
            M_sigs->dmem_write = false;
            W_sigs->wval_sel = true;
            W_sigs->w_enable = true;
            break;
        case OP_ADD_RI:
        case OP_SUB_RI:
        case OP_ADRP:
        case OP_LSL:
        case OP_LSR:
        case OP_ASR:
            W_sigs->w_enable = true;
            W_sigs->wval_sel = false;
            break;
        case OP_MOVK:
        case OP_MOVZ:
            W_sigs->w_enable = true;
            break;
        case OP_ADDS_RR:
        case OP_SUBS_RR:
        case OP_ANDS_RR:
            X_sigs->set_CC = true;
            X_sigs->valb_sel = true;
            W_sigs->w_enable = true;
            break;
        case OP_CMP_RR:
        case OP_TST_RR:
            X_sigs->set_CC = true;
            X_sigs->valb_sel = true;
            W_sigs->w_enable = false;
            break;
        case OP_ORR_RR:
        case OP_EOR_RR:
        case OP_MVN:
            X_sigs->valb_sel = true;
            W_sigs->w_enable = true;
            break;
        case OP_BL:
            W_sigs->dst_sel = true;
            W_sigs->w_enable = true;
            break;
        case OP_ERROR:
            W_sigs->w_enable = false;
            break;
        default:
            X_sigs->set_CC = false;
            break;
        
    }
    
    return;
}

/*
 * Logic for extracting the immediate value for M-, I-, and RI-format instructions.
 * STUDENT TO-DO:
 * Extract the immediate value and write it to *imm.
 */

static comb_logic_t 
extract_immval(uint32_t insnbits, opcode_t op, int64_t *imm) {
    switch(op) {
        //M Format
        case OP_LDUR:
        case OP_STUR:
            *imm = bitfield_s64(insnbits, 12, 9);
            break;
        //Format I1
        case OP_MOVK:
        case OP_MOVZ:
            *imm = bitfield_u32(insnbits, 5, 16);
            break;
        //format I2
        case OP_ADRP:
            *imm = bitfield_s64(insnbits, 5, 19) << 14;
            break;
        //R1 format
        case OP_ADD_RI:
        case OP_SUB_RI:
            *imm = bitfield_u32(insnbits, 10, 12);
            break;
        case OP_LSL:
            *imm = (64 - bitfield_u32(insnbits, 16, 6)) ;
            break;
        case OP_LSR:
        case OP_ASR:
            *imm = bitfield_u32(insnbits, 16, 5);
            break;
        //B1 format
        case OP_B:
      //  case OP_BL:
            *imm = bitfield_s64(insnbits, 0, 26);
            break;
        //B2 format
        case OP_B_COND:
            *imm = bitfield_s64(insnbits, 5, 19);
            break;
        default:
            break;
    }
    return;
}

/*
 * Logic for determining the ALU operation needed for this opcode.
 * STUDENT TO-DO:
 * Determine the ALU operation based on the given opcode
 * and write it to *ALU_op.
 */
static comb_logic_t
decide_alu_op(opcode_t op, alu_op_t *ALU_op) {
    switch(op) {
        case OP_ADD_RI:
        case OP_ADDS_RR:
        case OP_ADRP:
        case OP_LDUR:
        case OP_STUR:
            *ALU_op = PLUS_OP;
            break; //ldir stir
        case OP_SUB_RI:
        case OP_SUBS_RR:
        case OP_CMP_RR: //cmp just subtracts
            *ALU_op = MINUS_OP;
            break;
        // = neg op
        case OP_MVN:
            *ALU_op = NEG_OP;
            break;
        // = or op
        case OP_ORR_RR:
            *ALU_op = OR_OP;
            break;
        case OP_EOR_RR:
            *ALU_op = EOR_OP;
            break;
        // = and op
        case OP_ANDS_RR:
        case OP_TST_RR:
            *ALU_op = AND_OP;
            break;
        // MOV_OP,     
        case OP_MOVK:
        case OP_MOVZ:
            *ALU_op = MOV_OP;
            break;
        // LSL_OP,
        case OP_LSL:
        case OP_UBFM: //treat ubfm the same
            *ALU_op = LSL_OP;
            break;
        case OP_LSR:
            *ALU_op = LSR_OP;
            break;
        case OP_ASR:
            *ALU_op = ASR_OP;
            break;          
        // PASS_A_OP,  
        // PASS_B_OP,  
        // ERROR_OP = -1
        case OP_ERROR:
        //    *ALU_op = ERROR_OP;
            break;

        //PASS A, PASS_B left
        default:
            *ALU_op = PASS_A_OP;
            break;
    }
    return;
}

/*
 * Utility functions for copying over control signals across a stage.
 * STUDENT TO-DO:
 * Copy the input signals from the input side of the pipeline
 * register to the output side of the register.
 */

comb_logic_t 
copy_m_ctl_sigs(m_ctl_sigs_t *dest, m_ctl_sigs_t *src) {
    dest->dmem_read = src->dmem_read;
    dest->dmem_write = src->dmem_write;
    return;
}

comb_logic_t 
copy_w_ctl_sigs(w_ctl_sigs_t *dest, w_ctl_sigs_t *src) {
    dest->dst_sel = src->dst_sel;
    dest->w_enable = src->w_enable;
    dest->wval_sel = src->wval_sel;
    return;
}

comb_logic_t
extract_regs(uint32_t insnbits, opcode_t op, 
             uint8_t *src1, uint8_t *src2, uint8_t *dst) {
    switch(op) {
        //I1, I2 format:
        case OP_MOVK:
            *dst = bitfield_u32(insnbits, 0, 5);
            *src1 = *dst;
            break;
        case OP_MOVZ:
            *dst = bitfield_u32(insnbits, 0, 5);
            break;
        //RR Format:
        case OP_CMP_RR:
            *src1 = bitfield_u32(insnbits, 5, 5);
            *src2 = bitfield_u32(insnbits, 16, 5);
            *dst = -100;
            break;
        case OP_MVN:
        case OP_ADDS_RR:
        case OP_SUBS_RR:
        case OP_ORR_RR:
        case OP_EOR_RR:
        case OP_ANDS_RR:
            *src1 = bitfield_u32(insnbits, 5, 5);
            *src2 = bitfield_u32(insnbits, 16, 5);
            *dst = bitfield_u32(insnbits, 0, 5);
            if(op && *src1 == 31) {
                *src1 = 32;
            }
            if(op && *src2 == 31) {
                *src2 = 32;
            }
            break;
        case OP_TST_RR:
            *src1 = bitfield_u32(insnbits, 5, 5);
            *src2 = bitfield_u32(insnbits, 16, 5);
            *dst = XZR_NUM;
            if(op && *src1 == 31) {
                *src1 = 32;
            }
            if(op && *src2 == 31) {
                *src2 = 32;
            }
            break;
        case OP_ADRP:
            *dst = bitfield_u32(insnbits, 0, 5);
            break;
        //RI format and B3:
        case OP_ADD_RI:
        case OP_SUB_RI:
        case OP_LSL:
        case OP_LSR:
        case OP_UBFM:
        case OP_ASR:
            *src1 = bitfield_u32(insnbits, 5, 5);
            *dst = bitfield_u32(insnbits, 0, 5);
            break;
        case OP_RET:
            *src1 = bitfield_u32(insnbits, 5, 5);

            break;
        //M format: Rt is destination for LDUR and source for STUR
        case OP_LDUR:
            *src1 = bitfield_u32(insnbits, 5, 5);
            *dst = bitfield_u32(insnbits, 0, 5);
            break;
        case OP_STUR:
            *src1 = bitfield_u32(insnbits, 5, 5);
            *src2 = bitfield_u32(insnbits, 0, 5);
            *dst = bitfield_u32(insnbits, 0, 5);
            break;
        case OP_BL:
            *dst = 30;
            break;
        default:
            break;
    }
    return;
}

/*
 * Decode stage logic.
 * STUDENT TO-DO:
 * Implement the decode stage.
 * 
 * Use `in` as the input pipeline register,
 * and update the `out` pipeline register as output.
 * Additionally, make sure the register file is updated
 * with W_out's output when you call it in this stage.
 * 
 * You will also need the following helper functions:
 * generate_DXMW_control, regfile, extract_immval,
 * and decide_alu_op.
 */

comb_logic_t decode_instr(d_instr_impl_t *in, x_instr_impl_t *out) {
    // out->val_a = 0;
   // if(in->op != OP_NOP) {
    out->seq_succ_PC = in->seq_succ_PC;
    //printf("DECODE SEQ SUCC: %x\n", out->seq_succ_PC);
   // }
    d_ctl_sigs_t D_sigs; //used in decode, so figured I use it within this method
    generate_DXMW_control(in->op, &D_sigs, &out->X_sigs, &out->M_sigs, &out->W_sigs);
    extract_immval(in->insnbits, in->op, &out->val_imm);
    decide_alu_op(in->op, &out->ALU_op);
    //generate_DMXW_control: op, d, out= x, m, w
    // if(X_out->status == STAT_HLT) {
    //     in->status = STAT_HLT;
    //     out->status = STAT_HLT;
    // }
    
    
    
    //src1 and src2 is from the instruction bits
    uint8_t src1 = XZR_NUM;
    uint8_t src2 = XZR_NUM;
    uint8_t dst; // = out->dst;
    extract_regs(in->insnbits, in->op, &src1, &src2, &dst); //use dsigs, to choose which one is src2 since it



    //for m format, first one is destination register and second is src register
    //val w and w enable    
    regfile(src1, src2, W_out->dst, W_wval, W_out->W_sigs.w_enable, &out->val_a, &out->val_b);
    
    //special cases for operators
    if(in->op == OP_MOVK || in->op == OP_MOVZ) {
        out->val_hw = bitfield_u32(in->insnbits, 21, 2) << 4;
    } else {
        out->val_hw = 0;
    }

    if(in->op == OP_ADD_RI || in->op == OP_SUB_RI) {
        out->val_b = 0;
    }

    if(in->op == OP_MVN) {
        out->val_a = 0;
        out->val_imm = 0;
    }
    // else if(in->op == OP_TST_RR) {
    //     out->val_b = 0;
    // } 
    else if(in->op == OP_ADRP) {
        out->val_imm += bitfield_s64(in->insnbits, 29, 2) << 12;
        out->val_a += 0x400000;
    }
    if(in->op != OP_LDUR) {
        out->M_sigs.dmem_read = false;
    }
    if(in->op == OP_TST_RR) {
        out->val_imm = 0;
    }
    

    
    out->dst = dst;
    

    if(in->op == OP_BL) {
        //out->val_a = in->seq_succ_PC;
    }

    if(in->op == OP_CMP_RR) {
        out->dst = XZR_NUM;
    }
    out->print_op = in->print_op;
    if(in->op == OP_B_COND) {
        out->cond = bitfield_u32(in->insnbits, 0, 4);
        out->val_imm = 0;
        out->op = in->op;
    }
    out->status = in->status;
    out->op = in->op;
    
    
    if(in->op == OP_RET || in->op == OP_NOP) {
        out->val_hw = 0;
        out->val_imm = 0;
        out->dst = X_in->dst;
        out->ALU_op = PASS_A_OP;
        out->W_sigs.w_enable = false;
        out->X_sigs.valb_sel = false;
        out->W_sigs.wval_sel = false;
        out->X_sigs.set_CC = false;
        out->M_sigs.dmem_write = false;
    }
    forward_reg(src1, src2, X_out->dst, M_out->dst, W_out->dst, M_in->val_ex, M_out->val_ex, W_in->val_mem, W_out->val_ex, W_out->val_mem, M_out->W_sigs.wval_sel, W_out->W_sigs.wval_sel, X_out->W_sigs.w_enable, M_out->W_sigs.w_enable, W_out->W_sigs.w_enable, &out->val_a, &out->val_b);
    return;
}
